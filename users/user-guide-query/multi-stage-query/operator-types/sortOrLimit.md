---
description: >-
  Describes the sort or limit relation operator in the multi-stage query engine.
---

# Sort or limit relational operator
The sort or limit operator is used to sort the input data, limit the number of rows emitted by the operator or both.
This operator is generated by the multi-stage query engine when you use an `order by`, `limit` or `offset` operation in
a query.

## Implementation details

### Blocking nature

## Hints
None

## Stats
### executionTimeMs
Type: Long

The summation of time spent by all threads executing the operator.
This means that the wall time spent in the operation may be smaller that this value if the parallelism is larger than 1.

### emittedRows
Type: Long

The number of groups emitted by the operator.

## Explain attributes

## Tips and tricks

### Limit and offset can prevent filter pushdown
In SQL, usually `limit` and `offset` are used in the last stage of the query. 
But when being used in the middle of the query (like in a subquery or a CTE), it can prevent filter pushdown 
optimization.

For example, imagine the following query:
```sql
select 
a.* 
from userAttributes as a
join userGroups as g
on a.userUUID = g.userUUID
where a.deviceOS = 'windows'
```

This query may generate the plan:
```
LogicalProject(daysSinceFirstTrip=[$0], deviceOS=[$1], totalTrips=[$2], userUUID=[$3])
  LogicalJoin(condition=[=($3, $4)], joinType=[inner])
    PinotLogicalExchange(distribution=[hash[3]])
      LogicalProject(daysSinceFirstTrip=[$3], deviceOS=[$4], totalTrips=[$5], userUUID=[$6])
        LogicalFilter(condition=[=($4, _UTF-8'windows')])
          LogicalTableScan(table=[[default, userAttributes]])
    PinotLogicalExchange(distribution=[hash[0]])
      LogicalProject(userUUID=[$4])
        LogicalTableScan(table=[[default, userGroups]])
```

We can see that the filter `deviceOS = 'windows'` is pushed down to the leaf stage.
This reduce the amount of data that needs to be scanned and can improve the query performance, specially if there
is an inverted index in the `deviceOS` column.

But if we modify the query to add a `limit` to the `userAttributes` table scan:
```sql
select 
a.* 
from (select * from userAttributes limit 10) as a
join userGroups as g
on a.userUUID = g.userUUID
where a.deviceOS = 'windows'
```

The generated plan will be:
```
LogicalProject(daysSinceFirstTrip=[$0], deviceOS=[$1], totalTrips=[$2], userUUID=[$3])
  LogicalJoin(condition=[=($3, $4)], joinType=[inner])
    PinotLogicalExchange(distribution=[hash[3]])
      LogicalFilter(condition=[=($1, _UTF-8'windows')])
        LogicalSort(offset=[0], fetch=[10])
          PinotLogicalSortExchange(distribution=[hash], collation=[[]], isSortOnSender=[false], isSortOnReceiver=[false])
            LogicalSort(fetch=[10])
              LogicalProject(daysSinceFirstTrip=[$3], deviceOS=[$4], totalTrips=[$5], userUUID=[$6])
                LogicalTableScan(table=[[default, userAttributes]])
    PinotLogicalExchange(distribution=[hash[0]])
      LogicalProject(userUUID=[$4])
        LogicalTableScan(table=[[default, userGroups]])
```

Here we can see that the filter `deviceOS = 'windows'` is not pushed down leaf stage, which
means that the engine will need to scan all the data in the `userAttributes` table and then apply the filter.

The reason why the filter is not pushed down is that the `limit` operation must be applied before the filter in order
to do not break the semantics, which in this case are saying that we want the 10 rows of the `userAttributes` table
without considering their `deviceOS` value.

In case where you actually want to apply the filter before the `limit`, you can specify the where clause in the 
subquery. For example:

```sql
select 
a.* 
from (select * from userAttributes where deviceOS = 'windows' limit 10) as a
join userGroups as g
on a.userUUID = g.userUUID
```

Which will produce the following plan:
```
LogicalProject(daysSinceFirstTrip=[$0], deviceOS=[$1], totalTrips=[$2], userUUID=[$3])
  LogicalJoin(condition=[=($3, $4)], joinType=[inner])
    PinotLogicalExchange(distribution=[hash[3]])
      LogicalSort(offset=[0], fetch=[10])
        PinotLogicalSortExchange(distribution=[hash], collation=[[]], isSortOnSender=[false], isSortOnReceiver=[false])
          LogicalSort(fetch=[10])
            LogicalProject(daysSinceFirstTrip=[$3], deviceOS=[$4], totalTrips=[$5], userUUID=[$6])
              LogicalFilter(condition=[=($4, _UTF-8'windows')])
                LogicalTableScan(table=[[default, userAttributes]])
    PinotLogicalExchange(distribution=[hash[0]])
      LogicalProject(userUUID=[$4])
        LogicalTableScan(table=[[default, userGroups]])
```

As you can see, the filter is pushed down to leaf stage, which will reduce the amount of data