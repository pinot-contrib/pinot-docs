# Monitoring Metrics

Pinot provides metrics out of the box so that you can monitor every aspect of performance and robustness of the Pinot cluster. Most of the metrics are available either at table level or instance level. The metrics can be divided into the following major types when plotting -&#x20;

* **Gauge** - These represent a single value at any point in time.
* **Meter** - These represent rates of the metric per minute, per 5 minute etc.
* **Timer** - These metrics record durations and can be used to fetch average last 5 minute duration, 99 percentile values, min-max values etc.

### Pinot Server&#x20;

<table><thead><tr><th>Metric Name</th><th>Description</th><th data-type="select">Metric type</th></tr></thead><tbody><tr><td>TOTAL-QUERY-TIME</td><td>Total time to take from receiving the query to finishing its execution.</td><td></td></tr><tr><td>LLC-PARTITION-CONSUMING</td><td>This gives a binary value based on whether low-level consumption is healthy (1) or unhealthy (0). It’s important to ensure at least a single replica of each partition is consuming.</td><td></td></tr><tr><td>HIGHEST-STREAM-OFFSET-CONSUMED</td><td>The highest offset which has been consumed so far</td><td></td></tr><tr><td>DOCUMENT_COUNT</td><td>total number of records in table</td><td></td></tr><tr><td>SEGMENT_COUNT</td><td>total number of segments in table</td><td></td></tr><tr><td>UPSERT_PRIMARY_KEYS_COUNT</td><td>total unique primary keys in table</td><td></td></tr><tr><td>LAST_REALTIME_SEGMENT_CREATION_DURATION_SECONDS</td><td>time in seconds it took for latest realtime segment to get created</td><td></td></tr><tr><td>LAST_REALTIME_SEGMENT_CREATION_WAIT_TIME_SECONDS</td><td>time in seconds it took for segment creation to start (generally due to waiting for a lock to get acquired)</td><td></td></tr><tr><td>LAST_REALTIME_SEGMENT_INITIAL_CONSUMPTION_DURATION_SECONDS</td><td>time in seconds spent consuming records for latest segment</td><td></td></tr><tr><td>LAST_REALTIME_SEGMENT_CATCHUP_DURATION_SECONDS</td><td>time in seconds spent on catching up to the latest offset in metadata. This can happen when multiple servers are consuming from same partition.</td><td></td></tr><tr><td>LAST_REALTIME_SEGMENT_COMPLETION_DURATION_SECONDS</td><td>time in seconds between when we stopped consuming records and when the segment gets committed</td><td></td></tr><tr><td>REALTIME_OFFHEAP_MEMORY_USED</td><td>off heap memory in bytes current used by realtime segments</td><td></td></tr><tr><td>REALTIME_SEGMENT_NUM_PARTITIONS</td><td>Number of partitions for a table</td><td></td></tr><tr><td>LLC_SIMULTANEOUS_SEGMENT_BUILDS</td><td>Number of segments being built currently</td><td></td></tr><tr><td>ROWS_WITH_ERRORS</td><td>number of rows that either didn't get transformed or didn't get indexed.</td><td></td></tr><tr><td>REALTIME_ROWS_CONSUMED</td><td>total number of records consumed from input</td><td></td></tr><tr><td>INVALID_REALTIME_ROWS_DROPPED</td><td>number of records that were filtered based on FilterConfig specified in table config</td><td></td></tr><tr><td>REALTIME_CONSUMPTION_EXCEPTIONS</td><td>number of rows that were not consumed because of some exception. It doesn't track exceptions during transformation and indexing. </td><td></td></tr><tr><td>RELOAD_FAILURES</td><td>Number of failures occurred while reloading segments</td><td></td></tr><tr><td>REFRESH_FAILURES</td><td>Number of failures occurred while refreshing segments</td><td></td></tr><tr><td>UNTAR_FAILURES</td><td>Number of failures occurred while uncompressing segments</td><td></td></tr><tr><td>SEGMENT_DOWNLOAD_FAILURES</td><td>Number of failures occurred while downloading segments from deep store to local</td><td></td></tr><tr><td>DELETED_SEGMENT_COUNT</td><td>Number of segments deleted either because of retention policies, explicit delete request etc. </td><td></td></tr><tr><td>QUERIES</td><td>Number of queries executed </td><td></td></tr><tr><td>QUERY_EXECUTION_EXCEPTIONS</td><td>Number of exceptions encountered during query execution</td><td></td></tr><tr><td>NUM-MISSING-SEGMENTS</td><td>Number of missing segments that the broker queried for (expected to be on the server) but the server didn’t have. This can be due to retention or stale routing table</td><td></td></tr><tr><td>NO_TABLE_ACCESS</td><td>number of query requests for which table access was denied either due to table not being present or access control restrictions.</td><td></td></tr><tr><td>HELIX_ZOOKEEPER_RECONNECTS</td><td>Number of times Server instance re-connected to zookeeper.</td><td></td></tr><tr><td>NETTY_CONNECTION_BYTES_RECEIVED</td><td>total bytes received by the server</td><td></td></tr><tr><td>NETTY_CONNECTION_BYTES_SENT</td><td>total bytes sent by the server</td><td></td></tr><tr><td>NETTY_CONNECTION_RESPONSES_SENT</td><td>total responses sent by the server</td><td></td></tr></tbody></table>



### Pinot Broker&#x20;

<table><thead><tr><th>Metric Name</th><th>Description</th><th data-type="select">Metric Type</th></tr></thead><tbody><tr><td>UNHEALTHY_SERVERS</td><td>Number of unhealthy servers detected</td><td></td></tr><tr><td>QUERY_QUOTA_CAPACITY_UTILIZATION_RATE</td><td>percentage of configured rate limit being used on each broker</td><td></td></tr><tr><td>MAX_BURST_QPS</td><td></td><td></td></tr><tr><td>QUERY_RATE_LIMIT_DISABLED</td><td>1 if rate limit is enabled on broker, 0 otherwise</td><td></td></tr><tr><td>REQUEST_SIZE</td><td>Query String length on each broker</td><td></td></tr><tr><td>RESIZE_TIME_MS</td><td>time spent in resizing results for the output. either because of LIMIT or maximum allowed group by keys or any other criteria</td><td></td></tr><tr><td>QUERIES</td><td>The rate which an individual broker is receiving queries. Units are in QPS</td><td></td></tr><tr><td>REQUEST_COMPILATION_EXCEPTIONS</td><td>Number of queries which failed during compilation</td><td></td></tr><tr><td>RESOURCE_MISSING_EXCEPTIONS</td><td>Number of queries for which table doesn't exists</td><td></td></tr><tr><td>QUERY_VALIDATION_EXCEPTIONS</td><td>Number of invalid queries</td><td></td></tr><tr><td>UNKNOWN_COLUMN_EXCEPTIONS</td><td>Number of queries with unknown columns</td><td></td></tr><tr><td>NO_SERVER_FOUND_EXCEPTIONS</td><td>Number of queries for which no server was found to contain its data</td><td></td></tr><tr><td>REQUEST_TIMEOUT_BEFORE_SCATTERED_EXCEPTIONS</td><td>Number of times query timed out before even being sent to the servers</td><td></td></tr><tr><td>REQUEST_CHANNEL_LOCK_TIMEOUT_EXCEPTIONS</td><td>number of times query failes while trying to acquire lock to server connections</td><td></td></tr><tr><td>REQUEST_SEND_EXCEPTIONS</td><td>Number of queries failed while sending to server</td><td></td></tr><tr><td>RESPONSE_FETCH_EXCEPTIONS</td><td>Number of queries failed while handling response from servers</td><td></td></tr><tr><td>DATA_TABLE_DESERIALIZATION_EXCEPTIONS</td><td>Number of queries failed while deserializing response data from servers</td><td></td></tr><tr><td>RESPONSE_MERGE_EXCEPTIONS</td><td>Number of queries that failed while merging responses from multiple servers. This can be due to schema inconsitency or any other issues</td><td></td></tr><tr><td>BROKER_RESPONSES_WITH_PROCESSING_EXCEPTIONS</td><td>Number of queries where atleast one exception occured</td><td></td></tr><tr><td>BROKER_RESPONSES_WITH_PARTIAL_SERVERS_RESPONDED</td><td>Number of queries with incomplete results due to missing responses from servers</td><td></td></tr><tr><td>BROKER_RESPONSES_WITH_NUM_GROUPS_LIMIT_REACHED</td><td>Number of queries where total number of groups exceeded configured limit (default limit - 100K)</td><td></td></tr><tr><td>DOCUMENTS_SCANNED</td><td>Total number of documents read from segments in each query</td><td></td></tr><tr><td>ENTRIES_SCANNED_IN_FILTER</td><td></td><td></td></tr><tr><td>ENTRIES_SCANNED_POST_FILTER</td><td></td><td></td></tr><tr><td>NUM_RESIZES</td><td>Number of result resizes for queries</td><td></td></tr><tr><td>REQUEST_DROPPED_DUE_TO_ACCESS_ERROR</td><td>Number of queries dropped due to invalid access permissions on table</td><td></td></tr><tr><td>GROUP_BY_SIZE</td><td>Number of rows in group by queries</td><td></td></tr><tr><td>TOTAL_SERVER_RESPONSE_SIZE</td><td>Total number of bytes received from servers for queries</td><td></td></tr><tr><td>QUERY_QUOTA_EXCEEDED</td><td>Number of queries failed due to query rate limit being breached</td><td></td></tr><tr><td>NO_SERVING_HOST_FOR_SEGMENT</td><td>Number of segments per query for which no servers are available</td><td></td></tr><tr><td>SERVER_MISSING_FOR_ROUTING</td><td>Number of servers that could not be added to routing table for query</td><td></td></tr><tr><td>NETTY_CONNECTION_REQUESTS_SENT</td><td>total number of requests sent to  servers</td><td></td></tr><tr><td>NETTY_CONNECTION_BYTES_SENT</td><td>total bytes sent to servers</td><td></td></tr><tr><td>NETTY_CONNECTION_BYTES_RECEIVED</td><td>total bytes received from servers</td><td></td></tr><tr><td>PROACTIVE_CLUSTER_CHANGE_CHECK</td><td>Number of  requests raised to zookeeper to check the cluster state such as IDEAL STATES, EXTERNAL VIEW etc.</td><td></td></tr><tr><td>HELIX_ZOOKEEPER_RECONNECTS</td><td>Number of times broker instance re-connected to zookeeper.</td><td></td></tr></tbody></table>



### Pinot Controller

<table><thead><tr><th>Metric Name</th><th>Description</th><th data-type="select">Metric Type</th></tr></thead><tbody><tr><td>PERCENT_SEGMENTS_AVAILABLE</td><td>Percentage of complete online replicas in external view as compared to replicas in ideal state</td><td></td></tr><tr><td>NUMBER_OF_REPLICAS</td><td>Total number of replicas available for table  </td><td></td></tr><tr><td>PERCENT_SEGMENTS_AVAILABLE</td><td>Percentage of complete online replicas in external view as compared to replicas in ideal state.</td><td></td></tr><tr><td>SEGMENTS_IN_ERROR_STATE</td><td>Number of segments in an <code>ERROR</code> state for a given table.</td><td></td></tr><tr><td>TABLE_STORAGE_QUOTA_UTILIZATION</td><td>Shows how much of the table’s storage quota is currently being used, metric will a percentage of a the entire quota. </td><td></td></tr><tr><td>LAST_PUSH_TIME_DELAY_HOURS</td><td>The time in hours since the last time an offline segment has been pushed to the controller.</td><td></td></tr><tr><td>HEALTHCHECK_OK_CALLS</td><td>Number of health check requests for which controller was healthy</td><td></td></tr><tr><td>HEALTHCHECK_BAD_CALLS</td><td>Number of health check requests for which controller was unhealthy</td><td></td></tr><tr><td>CONTROLLER_INSTANCE_POST_ERROR</td><td>Errors occurred while updating state for an instance (server and broker)</td><td></td></tr><tr><td>CONTROLLER_SEGMENT_UPLOAD_ERROR</td><td>Errors occurred while sending uploading segment request</td><td></td></tr><tr><td>CONTROLLER_SCHEMA_UPLOAD_ERROR</td><td>Errors occurred while uploading schema</td><td></td></tr><tr><td>CONTROLLER_TABLE_SCHEMA_UPDATE_ERROR</td><td>Errors occurred while updating schema</td><td></td></tr><tr><td>CONTROLLER_TABLE_ADD_ERROR</td><td>Errors occurred while adding table config</td><td></td></tr><tr><td>CONTROLLER_TABLE_UPDATE_ERROR</td><td>Errors occurred while updating table config</td><td></td></tr><tr><td>CONTROLLER_TABLE_TENANT_UPDATE_ERROR</td><td>Errors occurred while updating a Tenant</td><td></td></tr><tr><td>CONTROLLER_TABLE_TENANT_CREATE_ERROR</td><td>Errors occurred while creating a Tenant</td><td></td></tr><tr><td>CONTROLLER_TABLE_TENANT_DELETE_ERROR</td><td>Errors while deleting a Tenant</td><td></td></tr><tr><td>CONTROLLER_REALTIME_TABLE_SEGMENT_ASSIGNMENT_ERROR</td><td>Errors occurred while assigning a realtime segment to a server instance</td><td></td></tr><tr><td>CONTROLLER_LEADERSHIP_CHANGE_WITHOUT_CALLBACK</td><td>Number of times a controller loses/gains leadership without a callback from Helix</td><td></td></tr><tr><td>CONTROLLER_PERIODIC_TASK_RUN</td><td>Number of Periodic tasks running currently</td><td></td></tr><tr><td>CONTROLLER_PERIODIC_TASK_ERROR</td><td>Number of Periodic tasks that failed due to error</td><td></td></tr><tr><td>NUMBER_TIMES_SCHEDULE_TASKS_CALLED</td><td>Minion tasks schedule request sent to controller</td><td></td></tr><tr><td>NUMBER_TASKS_SUBMITTED</td><td>Number of minion tasks submitted to the controller.</td><td></td></tr><tr><td>NUMBER_SEGMENT_UPLOAD_TIMEOUT_EXCEEDED</td><td>Number of segments uploads failed due to timeout. Segments are re-uploaded in this case by controller itself.</td><td></td></tr><tr><td>CRON_SCHEDULER_JOB_TRIGGERED</td><td>Number of minion tasks triggered that use cron</td><td></td></tr><tr><td>NUMBER_ADHOC_TASKS_SUBMITTED</td><td>Number of minion ad-hoc tasks submitted</td><td></td></tr><tr><td>LLC_STATE_MACHINE_ABORTS</td><td>Number of times a realtime segment commit operation was aborted</td><td></td></tr><tr><td>LLC_ZOOKEEPER_FETCH_FAILURES</td><td>Number of Zookeeper metadata fetch requests failed</td><td></td></tr><tr><td>LLC_ZOOKEEPER_UPDATE_FAILURES</td><td>Number of Zookeeper metadata update requests failed</td><td></td></tr><tr><td>LLC_STREAM_DATA_LOSS</td><td>Indicates data loss for table either due to offsets available to consume from topic larger than the last stored offset in pinot or segment lost in CONSUMING state</td><td></td></tr><tr><td>HELIX_ZOOKEEPER_RECONNECTS</td><td>Number of times broker instance re-connected to zookeeper.</td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table>

